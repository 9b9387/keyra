{"version":3,"file":"bundle.js","sources":["../../src/lib/keyra-rule.ts","../../src/lib/keyra-data.ts","../../src/lib/generator.ts"],"sourcesContent":["// Password rule class definition\nexport class KeyraRule {\n  name: string;\n  length: number;\n  requireUppercase: boolean;\n  requireLowercase: boolean;\n  requireNumbers: boolean;\n  requireSymbols: boolean;\n  allowedSymbols: string;\n\n  constructor(\n    name: string = '',\n    length: number = DEFAULT_RULE.length,\n    requireUppercase: boolean = DEFAULT_RULE.requireUppercase,\n    requireLowercase: boolean = DEFAULT_RULE.requireLowercase,\n    requireNumbers: boolean = DEFAULT_RULE.requireNumbers,\n    requireSymbols: boolean = DEFAULT_RULE.requireSymbols,\n    allowedSymbols: string = DEFAULT_RULE.allowedSymbols\n  ) {\n    this.name = name;\n    this.length = length;\n    this.requireUppercase = requireUppercase;\n    this.requireLowercase = requireLowercase;\n    this.requireNumbers = requireNumbers;\n    this.requireSymbols = requireSymbols;\n    this.allowedSymbols = allowedSymbols;\n  }\n\n  // Validate if the rule is legal\n  public validate(): boolean {\n    if (this.length < 4) {\n      throw new Error('Minimum length cannot be less than 4');\n    }\n    // Ensure allowedSymbols only contains ASCII characters\n    if (!/^[\\x20-\\x7E]*$/.test(this.allowedSymbols)) {\n      throw new Error('Allowed symbols must only contain ASCII characters');\n    }\n    return true;\n  }\n\n  // Serialize the rule to JSON format\n  public serialize(): string {\n    // Directly serialize the entire object without manually listing each field\n    return JSON.stringify(this);\n  }\n\n  // Deserialize from JSON string to KeyraRule object\n  public static deserialize(jsonString: string): KeyraRule {\n    try {\n      const data = JSON.parse(jsonString);\n      return new KeyraRule(\n        data.name,\n        data.length,\n        data.requireUppercase,\n        data.requireLowercase,\n        data.requireNumbers,\n        data.requireSymbols,\n        data.allowedSymbols\n      );\n    } catch (error) {\n      throw new Error(`Failed to parse KeyraRule from JSON: ${error}`);\n    }\n  }\n\n  // Returns a string representation of the rule in a tree-like format\n  toString(): string {\n    return `Rule: ${this.name}\n    ├─ Length    : ${this.length}\n    ├─ Require uppercase : ${this.requireUppercase ? 'Yes' : 'No'}\n    ├─ Require lowercase : ${this.requireLowercase ? 'Yes' : 'No'}\n    ├─ Require numbers   : ${this.requireNumbers ? 'Yes' : 'No'}\n    ├─ Require symbols   : ${this.requireSymbols ? 'Yes' : 'No'}\n    └─ Allowed symbols   : ${this.requireSymbols ? this.allowedSymbols : 'None'}`;\n  }\n}\n\n// Default rule\nexport const DEFAULT_RULE: KeyraRule = new KeyraRule(\n  'default',\n  16,\n  true,\n  true,\n  true,\n  true,\n  '!@#$%^&*()_+-=[]{}|;:,.<>?'\n);\n\n","import { DEFAULT_RULE, KeyraRule } from './keyra-rule';\n\nexport class KeyraData {\n  serviceName: string;\n  version: number;\n  rule: KeyraRule;\n  note: string;\n  createDate: Date;\n  domain: string;\n\n  constructor(\n    serviceName: string,\n    version: number = 1,\n    rule: KeyraRule = DEFAULT_RULE,\n    note: string = '',\n    createDate: Date = new Date(),\n    domain: string = ''\n  ) {\n    this.serviceName = serviceName;\n    this.version = version;\n    this.rule = rule;\n    this.note = note;\n    this.createDate = createDate;\n    this.domain = domain;\n  }\n\n  /**\n   * Serialize the object to a JSON string\n   * @returns JSON string\n   */\n  serialize(): string {\n    return JSON.stringify(this);\n  }\n\n  /**\n   * Deserialize from JSON string to KeyraData object\n   * @param json JSON string\n   * @returns KeyraData object\n   */\n  static deserialize(json: string): KeyraData {\n    try {\n      const data = JSON.parse(json);\n      const rule_json = JSON.stringify(data.rule);\n      const keyraData = new KeyraData(\n        data.serviceName,\n        data.version,\n        KeyraRule.deserialize(rule_json),\n        data.note,\n        new Date(data.createDate),\n        data.domain\n      );\n      \n      return keyraData;\n    } catch (error) {\n      throw new Error(`Failed to deserialize KeyraData: ${error}`);\n    }\n  }\n\n  /**\n   * Returns a string representation of the KeyraData in a tree-like format\n   * @returns string representation\n   */\n  toString(): string {\n    return `Service: ${this.serviceName}\n    ├─ Version     : ${this.version}\n    ├─ Create Date : ${this.createDate.toLocaleString()}\n    ├─ Note        : ${this.note || 'None'}\n    ├─ Domain      : ${this.domain || 'None'}\n    └─ Rule        : ${this.rule.name}`;\n  }\n}","import * as crypto from 'crypto';\nimport { KeyraRule } from './keyra-rule';\nimport { KeyraData } from './keyra-data';\n\nexport class Generator {\n  /**\n   * Generate a hash for password creation\n   * \n   * @param masterPassword The master password used as the base for generating all service passwords\n   * @param serviceName The service name, ensuring unique passwords for each service\n   * @param version The password version, allowing password updates for specific services without changing the master password\n   * @returns A 64-byte hash buffer that serves as the basis for password generation\n   */\n  private generateHash(masterPassword: string, serviceName: string, version: number): Buffer {\n    const salt = Buffer.from(`${serviceName}:${version}`, 'utf8');\n    return crypto.scryptSync(masterPassword, salt, 64, {\n      N: 16384, // CPU/memory cost parameter\n      r: 8,     // Memory parameter\n      p: 1      // Parallelization parameter\n    });\n  }\n\n  /**\n   * Generate the actual password string based on the hash and rules\n   * \n   * @param hash The hash buffer generated from the master password and service information\n   * @param rule Password generation rules including length and character requirements\n   * @returns The password string generated according to the rules\n   */\n  private hash(hash: Buffer, rule: KeyraRule): string {\n    // 验证输入参数\n    if (!hash || !(hash instanceof Buffer)) {\n      throw new Error('Hash must be a valid Buffer');\n    }\n    \n    if (!rule || !(rule instanceof KeyraRule)) {\n      throw new Error('Rule must be a valid KeyraRule instance');\n    }\n\n    const uppercaseChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    const lowercaseChars = 'abcdefghijklmnopqrstuvwxyz';\n    const numberChars = '0123456789';\n    const symbolChars = Array.from(new Set(rule.allowedSymbols)).sort().join('');\n    \n    let availableChars = '';\n    if (rule.requireUppercase) availableChars += uppercaseChars;\n    if (rule.requireLowercase) availableChars += lowercaseChars;\n    if (rule.requireNumbers) availableChars += numberChars;\n    if (rule.requireSymbols) availableChars += symbolChars;\n    \n    // 确保有可用的字符集\n    if (availableChars.length === 0) {\n      throw new Error('No available characters for password generation. Please enable at least one character type.');\n    }\n    \n    const availableCharsArray = Array.from(availableChars);\n    for (let i = availableCharsArray.length - 1; i > 0; i--) {\n      const j = hash[(i * 7) % hash.length] % (i + 1);\n      [availableCharsArray[i], availableCharsArray[j]] = [availableCharsArray[j], availableCharsArray[i]];\n    }\n    availableChars = availableCharsArray.join('');\n    \n    let passwordChars: string[] = [];\n    \n    // Ensure required character types are included\n    if (rule.requireUppercase) {\n      passwordChars.push(uppercaseChars[hash[0] % uppercaseChars.length]);\n    }\n    \n    if (rule.requireLowercase) {\n      passwordChars.push(lowercaseChars[hash[1] % lowercaseChars.length]);\n    }\n    \n    if (rule.requireNumbers) {\n      passwordChars.push(numberChars[hash[2] % numberChars.length]);\n    }\n    \n    if (rule.requireSymbols && symbolChars.length > 0) {\n      passwordChars.push(symbolChars[hash[3] % symbolChars.length]);\n    }\n    \n    // 验证密码长度设置是否合理\n    if (rule.length < passwordChars.length) {\n      throw new Error(`Password length (${rule.length}) must be at least ${passwordChars.length} to accommodate required character types`);\n    }\n    \n    // Fill to the required length using the remaining hash portions\n    const remainingLength = rule.length - passwordChars.length;\n    for (let i = 4; i < 4 + remainingLength && i < hash.length; i++) {\n      passwordChars.push(availableChars[hash[i] % availableChars.length]);\n    }\n    \n    // Shuffle the password characters deterministically\n    for (let i = passwordChars.length - 1; i > 0; i--) {\n      const j = hash[i % hash.length] % (i + 1); // Use hash value to generate index, ensuring determinism\n      [passwordChars[i], passwordChars[j]] = [passwordChars[j], passwordChars[i]];\n    }\n    \n    return passwordChars.join('');\n  }\n\n  /**\n   * Password generation function that converts a master password \n   * and service data into a deterministic password\n   * \n   * @param masterPassword The user's master password\n   * @param data Data object containing service name, version, and password rules\n   * @returns The generated password string\n   * @throws Error if validation fails\n   */\n  public generate(masterPassword: string, data: KeyraData): string {\n\n    if (!masterPassword || typeof masterPassword !== 'string') {\n      throw new Error('Master password must be a non-empty string');\n    }\n\n    if (!data.serviceName || typeof data.serviceName !== 'string') {\n      throw new Error('Service name must be a non-empty string');\n    }\n\n    if (data.rule.validate() === false) {\n      throw new Error('Invalid password rule');\n    }\n    \n    const hash = this.generateHash(masterPassword, data.serviceName, data.version);\n    return this.hash(hash, data.rule);\n  }\n}"],"names":["KeyraRule","constructor","name","length","DEFAULT_RULE","requireUppercase","requireLowercase","requireNumbers","requireSymbols","allowedSymbols","this","validate","Error","test","serialize","JSON","stringify","deserialize","jsonString","data","parse","error","toString","KeyraData","serviceName","version","rule","note","createDate","Date","domain","json","rule_json","toLocaleString","generateHash","masterPassword","crypto.scryptSync","Buffer","from","N","r","p","hash","uppercaseChars","lowercaseChars","numberChars","symbolChars","Array","Set","sort","join","availableChars","availableCharsArray","i","j","passwordChars","push","remainingLength","generate"],"mappings":"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"}